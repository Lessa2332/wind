<!DOCTYPE html>
<html lang="uk">
<head>
    <meta charset="utf-8">
    <title>–í—ñ—Ç–µ—Ä! –î–º–∏ –≤ –º—ñ–∫—Ä–æ—Ñ–æ–Ω üå¨Ô∏è</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <style>
        body { margin: 0; overflow: hidden; font-family: sans-serif; }
        #canvas { position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: 1; }
        #video { position: fixed; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover; z-index: 0; transform: scaleX(-1); }
        #start { position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); padding: 20px 40px; font-size: 28px; background: #4CAF50; color: white; border: none; border-radius: 20px; z-index: 10; cursor: pointer; }
        #info { position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%); background: rgba(0,0,0,0.7); color: white; padding: 15px; border-radius: 15px; text-align: center; font-size: 18px; z-index: 10; display: none; }
        #scale { position: fixed; top: 20px; left: 50%; transform: translateX(-50%); width: 80%; height: 30px; background: gray; border-radius: 15px; overflow: hidden; z-index: 10; display: none; }
        #bar { height: 100%; width: 0%; transition: width 0.3s, background 0.3s; }
    </style>
    <script src="https://cdn.jsdelivr.net/npm/three@0.168.0/build/three.min.js"></script>
</head>
<body>
    <video id="video" autoplay playsinline></video>
    <canvas id="canvas"></canvas>
    <button id="start">üå¨Ô∏è –ü–æ—á–∞—Ç–∏! –î–º–∏ –≤ –º—ñ–∫—Ä–æ—Ñ–æ–Ω</button>
    <div id="info">–î–º–∏ —Å–∏–ª—å–Ω—ñ—à–µ ‚Äî –≤—ñ—Ç–µ—Ä —à–≤–∏–¥—à–∏–π!<br>–ó–µ–ª–µ–Ω–∏–π ‚Äî —Å–ª–∞–±–∫–∏–π, –ß–µ—Ä–≤–æ–Ω–∏–π ‚Äî —Å–∏–ª—å–Ω–∏–π!</div>
    <div id="scale"><div id="bar"></div></div>

    <script>
        let video, scene, camera, renderer, particles, windForce = 0;
        const startBtn = document.getElementById('start');
        const info = document.getElementById('info');
        const scale = document.getElementById('scale');
        const bar = document.getElementById('bar');

        startBtn.onclick = async () => {
            startBtn.style.display = 'none';
            info.style.display = 'block';
            scale.style.display = 'block';

            // –ö–∞–º–µ—Ä–∞ —è–∫ —Ñ–æ–Ω (AR)
            video = document.getElementById('video');
            const stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: 'environment' }, audio: true });
            video.srcObject = stream;
            video.play();

            // Three.js
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 100);
            renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('canvas'), alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);

            // –ß–∞—Å—Ç–∏–Ω–∫–∏ –≤—ñ—Ç—Ä—É (—Å—Ñ–µ—Ä–∏ + –∫–æ–Ω—É—Å–∏)
            const particleCount = 500;
            const geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(particleCount * 3);
            const colors = new Float32Array(particleCount * 3);
            const sizes = new Float32Array(particleCount);
            const types = new Float32Array(particleCount); // 0 = —Å—Ñ–µ—Ä–∞, 1 = –∫–æ–Ω—É—Å

            for (let i = 0; i < particleCount; i++) {
                positions[i*3] = (Math.random() - 0.5) * 10;
                positions[i*3+1] = (Math.random() - 0.5) * 10;
                positions[i*3+2] = (Math.random() - 0.5) * 10;
                colors[i*3] = 1; colors[i*3+1] = 1; colors[i*3+2] = 1;
                sizes[i] = Math.random() * 0.2 + 0.1;
                types[i] = Math.random() > 0.5 ? 0 : 1;
            }

            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
            geometry.setAttribute('type', new THREE.BufferAttribute(types, 1));

            const material = new THREE.ShaderMaterial({
                vertexShader: `
                    attribute float size;
                    attribute float type;
                    varying vec3 vColor;
                    void main() {
                        vColor = color;
                        vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
                        gl_PointSize = size * (300.0 / -mvPosition.z);
                        gl_Position = projectionMatrix * mvPosition;
                    }
                `,
                fragmentShader: `
                    varying vec3 vColor;
                    uniform float windForce;
                    void main() {
                        if (windForce < 0.3) gl_FragColor = vec4(0.0, 1.0, 0.0, 1.0); // –∑–µ–ª–µ–Ω–∏–π
                        else if (windForce < 0.6) gl_FragColor = vec4(1.0, 1.0, 0.0, 1.0); // –∂–æ–≤—Ç–∏–π
                        else gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0); // —á–µ—Ä–≤–æ–Ω–∏–π
                        gl_FragColor.rgb *= vColor;
                    }
                `,
                uniforms: { windForce: { value: 0 } },
                transparent: true,
                vertexColors: true
            });

            particles = new THREE.Points(geometry, material);
            scene.add(particles);

            // –ú—ñ–∫—Ä–æ—Ñ–æ–Ω + –¥–µ—Ç–µ–∫—Ü—ñ—è —Å–∏–ª–∏ –¥—É—Ç—Ç—è
            const audioContext = new AudioContext();
            const analyser = audioContext.createAnalyser();
            const microphone = audioContext.createMediaStreamSource(stream);
            microphone.connect(analyser);
            analyser.fftSize = 512;
            const dataArray = new Uint8Array(analyser.frequencyBinCount);

            function updateWind() {
                analyser.getByteTimeDomainData(dataArray);
                let sum = 0;
                for (let i = 0; i < dataArray.length; i++) {
                    let v = (dataArray[i] - 128) / 128;
                    sum += v * v;
                }
                windForce = Math.sqrt(sum / dataArray.length) * 3; // —Å–∏–ª–∞ –≤—ñ—Ç—Ä—É 0-1+
                windForce = Math.min(windForce, 1);

                material.uniforms.windForce.value = windForce;
                bar.style.width = (windForce * 100) + '%';
                if (windForce < 0.3) bar.style.background = 'green';
                else if (windForce < 0.6) bar.style.background = 'yellow';
                else bar.style.background = 'red';

                // –†—É—Ö —á–∞—Å—Ç–∏–Ω–æ–∫
                const positions = particles.geometry.attributes.position.array;
                for (let i = 0; i < particleCount; i++) {
                    positions[i*3 + 2] += windForce * 0.1; // –≤–ø–µ—Ä–µ–¥
                    if (positions[i*3 + 2] > 5) {
                        positions[i*3 + 2] = -5;
                        positions[i*3] = (Math.random() - 0.5) * 10;
                        positions[i*3 + 1] = (Math.random() - 0.5) * 10;
                    }
                }
                particles.geometry.attributes.position.needsUpdate = true;

                requestAnimationFrame(updateWind);
            }
            updateWind();

            animate();
        };

        function animate() {
            requestAnimationFrame(animate);
            particles.rotation.y += 0.001;
            renderer.render(scene, camera);
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
